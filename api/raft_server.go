package api

import (
	pb "KV-Store/proto" // Import the generated Proto code
	"KV-Store/raft"     // Import your Raft logic
	"context"
	"log"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// RaftServer acts as the bridge.
// It implements the "RaftServiceServer" interface generated by gRPC.
type RaftServer struct {
	pb.UnimplementedRaftServiceServer            // Required by gRPC for forward compatibility
	rf                                *raft.Raft // Pointer to your actual Raft instance
}

// NewRaftServer creates the bridge
func NewRaftServer(rf *raft.Raft) *RaftServer {
	return &RaftServer{rf: rf}
}

func (s *RaftServer) ensureReady(ctx context.Context) error {
	if err := ctx.Err(); err != nil {
		switch err {
		case context.Canceled:
			return status.Error(codes.Canceled, "request canceled by client")
		case context.DeadlineExceeded:
			return status.Error(codes.DeadlineExceeded, "request deadline exceeded")
		default:
			return status.Error(codes.Internal, "request context error")
		}
	}
	if s == nil || s.rf == nil {
		return status.Error(codes.FailedPrecondition, "raft service not initialized")
	}
	return nil
}

func (s *RaftServer) RequestVote(ctx context.Context, req *pb.RequestVoteRequest) (*pb.RequestVoteResponse, error) {
	if err := s.ensureReady(ctx); err != nil {
		return nil, err
	}
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be nil")
	}
	args := &raft.RequestVoteArgs{
		Term:         int(req.Term),
		CandidateId:  int(req.CandidateId),
		LastLogIndex: int(req.LastLogIndex),
		LastLogTerm:  int(req.LastLogTerm),
	}
	var reply raft.RequestVoteReply

	s.rf.RequestVote(args, &reply)

	return &pb.RequestVoteResponse{
		Term:        int32(reply.Term),
		VoteGranted: reply.VoteGranted,
	}, nil
}

func (s *RaftServer) AppendEntries(ctx context.Context, req *pb.AppendEntriesRequest) (*pb.AppendEntriesResponse, error) {
	if err := s.ensureReady(ctx); err != nil {
		return nil, err
	}
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be nil")
	}

	entries := make([]raft.LogEntry, 0, len(req.Entries))
	for _, e := range req.Entries {
		entries = append(entries, raft.LogEntry{
			Term:    int(e.Term),
			Index:   int(e.Index),
			Command: e.Command,
		})
	}

	args := &raft.AppendEntriesArgs{
		Term:         int(req.Term),
		LeaderId:     int(req.LeaderId),
		PrevLogIndex: int(req.PrevLogIndex),
		PrevLogTerm:  int(req.PrevLogTerm),
		Entries:      entries,
		LeaderCommit: int(req.LeaderCommit),
	}
	var reply raft.AppendEntriesReply

	s.rf.AppendEntries(args, &reply)
	if ctx.Err() != nil {
		log.Printf("raft AppendEntries finished but context ended: %v", ctx.Err())
		return nil, status.Error(codes.Canceled, "request context ended")
	}

	return &pb.AppendEntriesResponse{
		Term:          int32(reply.Term),
		Success:       reply.Success,
		ConflictIndex: int32(reply.ConflictIndex),
		ConflictTerm:  int32(reply.ConflictTerm),
	}, nil
}
